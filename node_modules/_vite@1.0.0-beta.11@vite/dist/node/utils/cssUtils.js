"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const transformUtils_1 = require("./transformUtils");
const pathUtils_1 = require("./pathUtils");
const resolveVue_1 = require("./resolveVue");
const hash_sum_1 = __importDefault(require("hash-sum"));
exports.urlRE = /url\(\s*('[^']+'|"[^"]+"|[^'")]+)\s*\)/;
exports.cssPreprocessLangRE = /(.+)\.(less|sass|scss|styl|stylus|postcss)$/;
exports.cssModuleRE = /(.+)\.module\.(less|sass|scss|styl|stylus|postcss|css)$/;
exports.isCSSRequest = (file) => file.endsWith('.css') || exports.cssPreprocessLangRE.test(file);
function rewriteCssUrls(css, replacerOrBase) {
    let replacer;
    if (typeof replacerOrBase === 'string') {
        replacer = (rawUrl) => {
            return path_1.default.posix.resolve(path_1.default.posix.dirname(replacerOrBase), rawUrl);
        };
    }
    else {
        replacer = replacerOrBase;
    }
    return transformUtils_1.asyncReplace(css, exports.urlRE, async (match) => {
        let [matched, rawUrl] = match;
        let wrap = '';
        const first = rawUrl[0];
        if (first === `"` || first === `'`) {
            wrap = first;
            rawUrl = rawUrl.slice(1, -1);
        }
        if (pathUtils_1.isExternalUrl(rawUrl) ||
            rawUrl.startsWith('data:') ||
            rawUrl.startsWith('#')) {
            return matched;
        }
        return `url(${wrap}${await replacer(rawUrl)}${wrap})`;
    });
}
exports.rewriteCssUrls = rewriteCssUrls;
async function compileCss(root, publicPath, { source, filename, scoped, modules, preprocessLang, preprocessOptions = {} }, isBuild = false) {
    const id = hash_sum_1.default(publicPath);
    const postcssConfig = await loadPostcssConfig(root);
    const { compileStyleAsync } = resolveVue_1.resolveCompiler(root);
    if (publicPath.endsWith('.css') &&
        !modules &&
        !postcssConfig &&
        !isBuild &&
        !source.includes('@import')) {
        // no need to invoke compile for plain css if no postcss config is present
        return source;
    }
    const { options: postcssOptions, plugins: postcssPlugins } = await resolvePostcssOptions(root, isBuild);
    const res = await compileStyleAsync({
        source,
        filename,
        id: `data-v-${id}`,
        scoped,
        modules,
        modulesOptions: {
            generateScopedName: `[local]_${id}`
        },
        preprocessLang: preprocessLang,
        preprocessCustomRequire: (id) => require(pathUtils_1.resolveFrom(root, id)),
        preprocessOptions: {
            includePaths: ['node_modules'],
            ...preprocessOptions
        },
        postcssOptions,
        postcssPlugins
    });
    // record css import dependencies
    if (res.rawResult) {
        res.rawResult.messages.forEach((msg) => {
            let { type, file, parent } = msg;
            if (type === 'dependency') {
                if (exports.cssImportMap.has(file)) {
                    exports.cssImportMap.get(file).add(parent);
                }
                else {
                    exports.cssImportMap.set(file, new Set([parent]));
                }
            }
        });
    }
    return res;
}
exports.compileCss = compileCss;
let cachedPostcssConfig;
async function loadPostcssConfig(root) {
    if (cachedPostcssConfig !== undefined) {
        return cachedPostcssConfig;
    }
    try {
        const load = require('postcss-load-config');
        return (cachedPostcssConfig = await load({}, root));
    }
    catch (e) {
        if (!/No PostCSS Config found/.test(e.message)) {
            console.error(chalk_1.default.red(`[vite] Error loading postcss config:`));
            console.error(e);
        }
        return (cachedPostcssConfig = null);
    }
}
async function resolvePostcssOptions(root, isBuild) {
    const config = await loadPostcssConfig(root);
    const options = config && config.options;
    const plugins = config ? config.plugins : [];
    plugins.unshift(require('postcss-import')());
    if (isBuild) {
        plugins.push(require('postcss-discard-comments')({ removeAll: true }));
    }
    return {
        options,
        plugins
    };
}
exports.resolvePostcssOptions = resolvePostcssOptions;
exports.cssImportMap = new Map();
function getCssImportBoundaries(filePath, boundaries = new Set()) {
    if (!exports.cssImportMap.has(filePath)) {
        return boundaries;
    }
    const importers = exports.cssImportMap.get(filePath);
    for (const importer of importers) {
        boundaries.add(importer);
        getCssImportBoundaries(importer, boundaries);
    }
    return boundaries;
}
exports.getCssImportBoundaries = getCssImportBoundaries;
//# sourceMappingURL=cssUtils.js.map